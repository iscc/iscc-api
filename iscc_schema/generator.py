# generated by datamodel-codegen:
#   filename:  iscc-service-generator.yaml
#   timestamp: 2022-01-31T19:53:57+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Field, confloat, conint, constr


class IsccGenerator(BaseModel):
    source_file: Optional[bytes] = Field(
        None, description="The media file used as source for ISCC generation."
    )
    source_url: Optional[AnyUrl] = Field(
        None, description="URL of a the media file used as source for ISCC generation."
    )


class IsccBasic(BaseModel):
    name: Optional[constr(min_length=1, max_length=128)] = Field(
        None,
        description=(
            "The title or name of the intangible creation manifested by the identified *digital"
            " content*. **Used as input for ISCC Meta-Code generation**."
        ),
        example="The Never Ending Story",
    )
    description: Optional[constr(min_length=1, max_length=1024)] = Field(
        None,
        description=(
            "Description of the *digital content* identified by the **ISCC**. **Used as input for"
            " ISCC Meta-Code generation**. Any user presentable text string (including Markdown"
            " text) indicative of the identity  of the referent may be used."
        ),
        example="a 1984 fantasy film co-written and directed by *Wolfgang Petersen*",
    )
    metadata: Optional[Union[Dict[str, Any], str]] = Field(
        None,
        description=(
            "Descriptive, industry-sector or use-case specific metadata. **Used as input for ISCC"
            " Meta-Code generation**. Can be any object that is JSON/JCS serializable. If"
            " `metadata` is provided it is used as an input for Meta-Code generation and as the"
            " sole input for the cryptographic `metahash` calculation. If `metadata` is set to a"
            " string it is assumed that it is base64 encoded binary file metadata."
        ),
    )


class IsccEmbeddable(BaseModel):
    creator: Optional[str] = Field(
        None,
        description="An entity primarily responsible for making the resource.",
        example="Joanne K. Rowling",
    )
    license: Optional[AnyUrl] = Field(
        None,
        description=(
            "URI of license for the identified *digital content*. **Supports URI template"
            " `{iscc-id}`**."
        ),
        example="https://example.com/license-terms-for-this-item",
    )
    acquire: Optional[AnyUrl] = Field(
        None,
        description=(
            "This field must contain a valid URL referring to a page showing information about how"
            " one can acquire a license for the item. This may be a page of a web shop or NFT"
            " marketplace ready for providing a license. **Supports URI template `{iscc-id}`**."
        ),
        example="https://example.com/buy-license-for-item-here",
    )
    credit: Optional[str] = Field(
        None,
        description=(
            "A line of text that you expect users of the image (such as Google Images) to display"
            " alongside the image."
        ),
        example="Frank Farian - Getty Images",
    )
    rights: Optional[str] = Field(
        None,
        description=(
            "Contains any necessary copyright notice and should identify the current owner of the"
            " copyright of this work with associated intellectual property rights."
        ),
        example="Â© Copyright 2022 ISCC Foundation - www.iscc.codes",
    )


class _Type(Enum):
    CreativeWork = "CreativeWork"
    TextDigitalDocument = "TextDigitalDocument"
    ImageObject = "ImageObject"
    AudioObject = "AudioObject"
    VideoObject = "VideoObject"


class IsccJsonld(BaseModel):
    _context: Optional[AnyUrl] = Field(
        "http://purl.org/iscc/context",
        alias="@context",
        description="The [JSON-LD](https://json-ld.org/) Context URI for ISCC metadata.",
    )
    _type: Optional[_Type] = Field(
        "CreativeWork",
        alias="@type",
        description=(
            "The type of digital content according to schema.org classes (TextDigitalDocument,"
            " ImageObject, AudioObject, VideoObject)."
        ),
    )
    _schema: Optional[AnyUrl] = Field(
        "http://purl.org/iscc/schema",
        alias="$schema",
        description="The [JSON Schema](https://json-schema.org/) URI for ISCC metadata.",
    )


class IsccMinimal(BaseModel):
    iscc: constr(regex=r"^ISCC:[A-Z2-7]{10,73}$", min_length=15, max_length=73) = Field(
        ...,
        description=(
            "An **ISCC-CODE** in canonical representation. This is the minimal required field for a"
            " valid ISCC Metadata object."
        ),
        example="ISCC:KACYPXW445FTYNJ3CYSXHAFJMA2HUWULUNRFE3BLHRSCXYH2M5AEGQY",
    )


class IsccCrypto(BaseModel):
    tophash: Optional[constr(min_length=40)] = Field(
        None,
        description=(
            "A [Multihash](https://multiformats.io/multihash/) of the concatenation (binding) of"
            " metahash and datahash (default blake3)."
        ),
    )
    metahash: Optional[constr(min_length=40)] = Field(
        None,
        description=(
            "A [Multihash](https://multiformats.io/multihash/) of the supplied metadata (default"
            " blake3). The hash is created from `name` and `description` fields or `properties` if"
            " supplied. For deterministic results [JSC"
            " RFC5452](https://datatracker.ietf.org/doc/html/rfc8785) canonicalization is applied"
            " to `properties` before hashing if it is a JSON object."
        ),
    )
    datahash: Optional[constr(min_length=40)] = Field(
        None,
        description=(
            "A [Multihash](https://multiformats.io/multihash/) of the *digital content* (default"
            " blake3)."
        ),
    )


class IsccTechnical(BaseModel):
    created: Optional[datetime] = Field(
        None, description="Datetime the ISCC was created for the item."
    )
    filename: Optional[str] = Field(
        None,
        description=(
            "Filename of the referenced **digital content** (automatically used as fallback if the"
            " `name` field was not specified for ISCC processing)"
        ),
    )
    filesize: Optional[int] = Field(
        None, description="File size of media asset in number of bytes."
    )
    mediatype: Optional[str] = Field(
        None,
        description=(
            "An [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)"
            " (MIME type)"
        ),
        example="image/png",
    )
    duration: Optional[int] = Field(None, description="Duration of audio-visual media in secondes.")
    fps: Optional[confloat(ge=1.0)] = Field(
        None, description="Frames per second of video assets.", example=24
    )
    width: Optional[int] = Field(
        None, description="Width of visual media in number of pixels.", example=640
    )
    height: Optional[conint(ge=1)] = Field(
        None, description="Height of visual media in number of pixels.", example=480
    )
    characters: Optional[int] = Field(
        None,
        description="Number of text characters (code points after Unicode normalization)",
        example=55689,
    )
    pages: Optional[int] = Field(
        None, description="Number of pages (for paged documents only)", example=77
    )
    language: Optional[Union[str, List[str]]] = Field(
        None,
        description="Language(s) of content [BCP 47](https://tools.ietf.org/search/bcp47).",
        example="en-US",
    )
    parts: Optional[List[str]] = Field(
        None,
        description=(
            "Indicates items that are part of this item via Content-Codes (inverse-property"
            " belongs)."
        ),
    )
    part_of: Optional[List[str]] = Field(
        None, description="Indicates that this item is part of other items via their Content-Code."
    )
    features: Optional[List[Dict[str, Any]]] = Field(
        None, description="Granular features of the *digital content*."
    )
    generator: Optional[str] = Field(
        None, description="Name and version of the software that generated the ISCC"
    )


class Chain(Enum):
    PRIVATE = "PRIVATE"
    BITCOIN = "BITCOIN"
    ETHEREUM = "ETHEREUM"
    POLYGON = "POLYGON"


class NftRequest(IsccGenerator, IsccBasic, IsccEmbeddable):
    chain: Optional[Chain] = Field(
        None, description="The blockchain used for NFT minting / ISCC decleration"
    )
    wallet: Optional[str] = Field(
        None,
        description=(
            "Wallet address of the declarer (must be used for the minting/decleration transaction)"
        ),
    )
    redirect: Optional[AnyUrl] = Field(
        None,
        description=(
            "URI to which an ISCC resolver should redirect for this item. **Supports URI template"
            " `{iscc-id}`**."
        ),
        example="https://example.com/{iscc-id}",
    )


class NftResponse(BaseModel):
    ipfs_cid: Optional[str] = Field(None, description="CIDv1 of NFT metadata (base16 encoded)")
    token_id: Optional[str] = Field(
        None, description="The token-id to use for NFT Minting (hex encoded)"
    )
    iscc_code: Optional[str] = Field(
        None, description="The ISCC to use for ISCC Declartion (hex encoded)"
    )
    ipfs_payload_metadata: Optional[str] = Field(
        None, description="The NFT metadata payload to be published via IPFS (base64 encoded)"
    )
    ipfs_payload_image: Optional[str] = Field(
        None,
        description=(
            "The NFT asset with embedded metadata to be published via IPFS (base64 encoded)"
        ),
    )


class IsccRequest(IsccGenerator, IsccBasic, IsccEmbeddable):
    pass


class IsccResponse(IsccJsonld, IsccMinimal, IsccBasic, IsccEmbeddable, IsccCrypto, IsccTechnical):
    pass
